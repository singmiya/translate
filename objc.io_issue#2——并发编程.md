【译】【原文】https://www.objc.io/issues/2-concurrency/
为避免撕逼，提前声明：本文纯属翻译，仅仅是为了学习，加上水平有限，见谅！

# 并发编程

## 编辑寄语

欢迎来到objc.io issue #2

首先，非常感谢大家对我们第一次issue的热烈响应——我们始料未及的好开端。

在这第二次issue，我们打算深入的去探究并发编程这个主题。目前，我们可以任意多核CPU，甚至是在移动设备上。如果我们正确的使用并发的话，就可以让我们的应用有一个极大的性能提升。

不幸的是，并发编程天生就存在很多复杂的问题和陷阱，不管API看起来有多么简单。我们希望本次issue的这篇文章让你对这个主题有更深刻的理解并帮助你避开很多潜在的陷阱。

这次issue我们非常高兴能够请到`Peter Steinberger`和`Tobias Kräntzer`作为特邀作者。`Peter`会分享来自他知名的`PSPDKit`库的关于并发编程的经验，而且`Tobias`编写了异步测试代码。

在未来，如果你有一个想要分享到objc.io的主题，请联系我们。

最后，对于请求RSS订阅的人，我们有一个好消息告诉你们：现在你可以在`objc.io/feed.xml`订阅objc.io了。

祝阅读愉快！

---

## 并发编程：APIs和挑战
并发描述了这样一个概念：同一时间运行运行多个任务。这不仅可以在单核CPU上以分时（time-shared）的方式发生，也可以在多核CPU可用的时候发生真正的并行操作。

OS X和iOS提供几种不同的APIs支持并发编程。每一种APIs都有其优势和局限性，使其适用于不同的任务场景。而且他们也处于不同的抽象层次。我们能够操作更接近底层的东西，但这样需要担负更大的责任才能把事情做好。

并发编程是一个有很多复杂问题和陷阱的高难度课题，并且在使用像GCD（Grand Central Dispatch）和`NSOperationQueue`这样的API的时候又极容易让人忘记这点。这篇文章首先会简单介绍一下OS X与iOS并发的不同之处，然后会深入介绍并发编程与生俱来的挑战，这挑战取决于你是用的特定API。


### OS X和iOS中的并发APIs
苹果的移动电话和桌面操作系统提供了相同的编发编程API。在这篇文章中，我们打算看一下`pthread`和`NSThread`，GCD（Grand Central Dispatch），`NSOperationQueue`和`NSRunLoop`。技术上，运行循环（NSRunLoop）在上述列表中格格不入，因为它并没有开启真正的并行。但是它们与这个话题关联极其紧密，很有必要对其进行更进一步的了解。

我们将从底层API开始，接着向高层API递进。我们这要做是因为高层API是基于底层API构建的。然而，当我们为你的用例选择API的时候，你应该逆序来考虑：选择高级别的抽象完成工作并且让并发模型保持简洁。

“为什么我们坚持推荐选择高级别的抽象和简单地并发代码？”，如果你对此感到困惑，你应该阅读这篇文章的第二部分，[并发编程的挑战]()。

#### 线程
线程是进程的基本单元，它是可以被操作系统的调度器进行单独带哦读的。几乎所有的并发API都是在以线程为底层的基础上构建的——GCD（Grand Central Dispatch）和操作队列（NSOperationQueue）也是如此。

多线程可以在单核CPU上同时执行（或者至少被认为同时）。操作系统会为每一个线程分配一个计算时间片，这样让用户看起来就像同时执行多个任务一样。如果多核CPU可用，那么多线程会以真正的并行执行，从而减少特定工作负载所需的总时间。

你可以使用


