*拒绝撕逼！！！
本片属于论文翻译，此翻译仅仅是为了学习，加上水平有限，见谅！*

【原文】**《MapReduce: Simplified Data Processing on Large Clusters》**，作者**Jeffrey Dea**n 和 **Sanjay Ghemawat**

# 分布式计算：简化大规模集群下的数据处理

## 摘要
分布式计算（MapReduce）是一个处理、生成大规模数据集的编程模型及其相关实现。用户指定一个`map`函数来处理键值对从而生成一组中间键值对，一个`reduce`函数用来合并中间键相同的所有值。正如本文中所示，很多现实中的任务都可以在这个模型中表达出来。

这种函数式编程可以自动的并行化，并在商用机器组成的大规模集群中执行。运行时系统注重输入数据的分割，一组机器之间程序执行的调度，故障机器的处理，所需机器间的通讯管理等这些细节。这允许没有并行和分布式系统经验的程序员可以轻松地利用大型分布式系统资源。

我们的分布式计算实现运行在由商用机器组成的大规模集群中且具有高可扩展性：一个典型的分布式计算过程需要在数以千计的机器上处理数兆兆字节的数据。程序员会发现系统使用很简单：现在已经有数以百计种分布式计算程序的实现方式，并且每天都有超过一千个分布式计算任务在Google的集群上执行。

---

## 1 简介
在过去的五年中，作者和很多其他Google的工作人员已经实现了数以百计有特殊用途的计算，这种计算会处理海量的原始数据，例如抓取的文档，网络请求日志等等，以计算出各种衍生数据，例如倒排索引，各种表征web文档的图结构，每个主机抓取的页面数摘要，一天中查询最频繁的关键字集合等等。从概念上讲，这样的计算大多数都很简单。然而，输入数据量通常会很大，并且计算必须分布在数百或者数千台机器上，以便在合理的时间内完成。如何进行并行计算，分发数据和处理故障，正是为了解决这些问题而使用了大量的复杂代码掩盖了原始的简单计算。

为了应对这种复杂性，我们设计了一个新的抽象概念，它允许我们表达我们想要执行的简单计算，但是隐藏了在一个库中并行，容错，数据分发，负载均衡等繁琐的细节。我们的抽象概念的灵感来源于Lisp和很多其他函数式语言中的内置函数`map`和`reduce`。我们意识到很多计算都涉及到向我们输入的每一个合理的“记录”都应用一个`map`操作来计算出一组中间键值对，向拥有共同键的所有值都应用一个`reduce`操作来适当的合并衍生出来的数据。我们使用带有用户指定`map`和`reduce`操作的函数模型能让我们轻松地进行大规模并行计算，并把重新执行作为主要的容错机制。

这项工作的主要贡献是提供了简单且强大的能够进行自动并行和大规模分布式计算的接口，结合该接口的实现，在大规模商用计算机集群上有着不俗的性能表现。

第二部分描述了基本的编程模型并给出了几个示例。第三部分描述了一个集群计算环境的分布式计算接口的实现。第四部分描述了我们发现的一个有用的改进编程模型。第五部分对各种任务的实现进行了性能评测。第六部分探讨了分布式计算在Google中的使用，包括我们将其作为基础而重写产品索引系统的经验。第七部分讨论了相关的和未来的工作。

---

## 2 编程模型
计算接受一组键值对作为输入，并生成一组键值对作为输出。分布式计算库的用户将计算表示为两个函数：*Map*和*Reduce*。

用户编写的*Map*函数接受一个输入对并生成一组中间键值对。分布式计算库把与中间key值 ***I*** 相同的所有中间value值组合到一起并传递给*Reduce*方法。

用户编写的*Reduce*函数接收一个中间key值 ***I*** 和一组与此key值相关的value值。他会合并这些值产生规模更小的一组value值。通常的，每一次*Reduce*调用只会生成0或者1个输出值。中间值通过迭代器把值提供给用户的*Reduce*函数。这样可以允许我们处理大到内存无法容纳的值列表。

### 2.1 示例
想一下这个问题：计算一下在一个大的文档集中每个单词出现的次数。用户可能会写下如下的伪代码：
```
map(String key, String value):
	// key: 文档名称
	// value: 文档内容
	for each word w in value:
		EmitIntermediate(w, "1");
		
reduce(String key, Iterator values):
	// key: 一个单词
	// values: 计数列表
	int result = 0;
	for each v in values:
		result += ParseInt(v);
	Emit(AsString(result));
```
`map`函数返回一个单词和与其相关出现次数（在这个例子中只为“1”）。`reduce`函数统计了一个特定单词返回的所有计数。

此外，用户编码用输入、输出文件的名称和可选的调优参数来满足一个符合`MapReduce`规范的对象。然后用户调用`MapReduce`函数，并传递给它一个规范的对象。让用户的代码与`MapReduce`库（由C++实现）连接在一起。附录A包含该示例的完整代码。

### 2.2 类型
尽管上面的伪代码的输入输出类型是`string`，但是，从概念上讲，用户提供的`map`和`reduce`函数都有与其对应的类型：
```
map(k1, v1)			         ---> list(k2, v2)
reduce(k2, list(v2))		----> list(v2)
```
也就是说，输入的键和值和输出的键和值来自不同的域。此外，中间键和值和输出的键和值来自相同的域。

我们的C++实现把字符串从用户定义的函数中传入和输出，并将其留给用户代码以让它在字符串和适当类型之间转换。


### 2.3 更多示例
下面有几个简单有趣的程序示例，可以很容易的将它们表示为分布式计算。

**Distributed Grep（正则表达式）：**如果输入值匹配给定的模式，`map`函数会输出一行。`reduce`函数是一个识别函数，仅仅把提供的中间函数拷贝到输出。

**统计URL访问频率：**`map`函数处理网页请求日志，并输出`<UEL, 1>`。`reduce`函数把所有URL相同的值累加起来并输出`<URL, total count>`数据对。

**反转网页链接图：**`map`函数为每一个在名为`source`的页面中能连接到`target` URL的链接输出`<target, source>`数据对。`reduce`函数会连接所有与给定target URL相关source URLs列表，并输出`<target, list<source>>`对。

**主机关键向量指标：**一个检索词向量摘录了出现在一个或一组文档中最重要的单词作为`<word, frequency>`列表。`map`函数为每一个输入文档（其中主机名是从文档的URL中提取的）输出一个`<hostname, term vector>`对。`reduce`函数接收给定的主机所有的单文档检索词向量。它会把这些检索词向量聚合在一起，丢弃低频检索词，然后输出最终的`<hostname, term vector>`数据对。

![]()


